ğŸ—» Longest Mountain in Array  

ğŸ“… Date: [07-01-25]  
ğŸ–¥ï¸ Platform: [LeetCode/GFG]  
âš¡ Difficulty: [Medium]  

ğŸ” Problem Understanding  
ğŸ¯ Input: An array `arr[]` of integers  
ğŸ¯ Output: Length of the longest mountain subarray  
ğŸ“ Constraints: `1 <= arr.length <= 10^4`, `0 <= arr[i] <= 10^4`  
ğŸ”„ Edge cases: No valid mountain, all increasing/decreasing, smallest valid mountain  

ğŸ’¡ Approach  
1ï¸âƒ£ Initial thoughts  
   ğŸ”¹ A mountain is a sequence of increasing elements followed by decreasing elements  
   ğŸ”¹ Identify peaks (`arr[i-1] < arr[i] > arr[i+1]`)  
   ğŸ”¹ Expand left and right to determine mountain length  

2ï¸âƒ£ Optimal solution  
   ğŸ”¹ Traverse array, detect peaks  
   ğŸ”¹ Expand left while `arr[j] > arr[j-1]`  
   ğŸ”¹ Expand right while `arr[k] > arr[k+1]`  
   ğŸ”¹ Track maximum mountain length  

3ï¸âƒ£ Time/Space Complexity  
   â³ Time Complexity: `O(N)`, iterating over the array  
   ğŸ’¾ Space Complexity: `O(1)`, using only integer variables  

ğŸ“ Pseudo Code  
ğŸ”¹ If `n < 3`, return `0`  
ğŸ”¹ Iterate `i` from `1` to `n-1`:  
   â– If `arr[i-1] < arr[i] > arr[i+1]`, it's a peak  
   â– Expand left while `arr[j] > arr[j-1]`  
   â– Expand right while `arr[k] > arr[k+1]`  
   â– Update `max` with the mountain length  
ğŸ”¹ Return `max`  

ğŸ’» Code  
```java
public int longestMountain(int[] arr) {
    int n = arr.length;
    if (n < 3) return 0;
    int max = 0;
    for (int i = 1; i < n - 1; i++) {
        if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {
            int j = i - 1, k = i + 1;
            while (j > 0 && arr[j] > arr[j - 1]) {
                j--;
            }
            while (k < n - 1 && arr[k] > arr[k + 1]) {
                k++;
            }
            max = Math.max(max, k - j + 1);
        }
    }
    return max;
}
```

ğŸ”— Similar Problems  
ğŸ¯ Longest Increasing Subsequence  
ğŸ¯ Find Peak Element  

ğŸ§ Review Notes  
âœ… Key insights: Expanding from peaks reduces unnecessary iterations  
âŒ Common mistakes: Not handling edge cases where no mountain exists  
âš¡ Optimization tips: Two-pass approach with prefix and suffix arrays
