ğŸ“Œ ğŸ“ˆ Stock Trading with at Most `k` Transactions  

ğŸ“… ğŸ”¹ Date: [09-01-25]  
ğŸ–¥ï¸ ğŸ” Platform: [LeetCode/GFG]  
âš¡ ğŸ¯ Difficulty: [Hard]  

ğŸ” ğŸ“ Problem Understanding  
â¡ï¸ **Input:** Integer `k` (max transactions), array `prices[]` (stock prices)  
â¡ï¸ **Output:** Maximum profit possible with at most `k` transactions  

ğŸ“ ğŸ”¢ Constraints  
â¡ï¸ `1 â‰¤ k â‰¤ 100`  
â¡ï¸ `1 â‰¤ prices.length â‰¤ 10^5`  
â¡ï¸ Prices are positive integers  

ğŸ”„ ğŸ› ï¸ Edge Cases  
â¡ï¸ `prices` is empty or has only one price  
â¡ï¸ `k` is large compared to the number of prices  
â¡ï¸ Prices are always increasing or decreasing  

ğŸ’¡ ğŸ” Approach  
ğŸ”¹ **Dynamic Programming**  
  ğŸ”¹ Use a `dp[k+1][n]` table where `dp[i][j]` stores the max profit using `i` transactions up to day `j`  
  ğŸ”¹ Initialize `dp` with zero profit for `0` transactions  
  ğŸ”¹ For each transaction count (`i`), iterate through each day (`j`)  
  ğŸ”¹ Maintain `effectiveBuyPrice`, which is the **minimum price** to buy considering previous transaction profits  
  ğŸ”¹ Update `dp[i][j]` as the max of:  
    ğŸ”¹ Not selling on day `j` (`dp[i][j-1]`)  
    ğŸ”¹ Selling on day `j` (`prices[j] - effectiveBuyPrice`)  
  ğŸ”¹ Return `dp[k][n-1]`, which contains the maximum profit possible  

â³ â±ï¸ Time Complexity: **O(k * n)**  
ğŸ’¾ ğŸ—ï¸ Space Complexity: **O(k * n)**  

ğŸ“ ğŸ”¢ Pseudo Code  
```plaintext
initialize dp[k+1][n] to store max profit for up to k transactions  
if n < 2 return 0  
for i = 1 to k:  
    set effectiveBuyPrice to prices[0]  
    for j = 1 to n:  
        update dp[i][j] as max of:  
            - not selling today (dp[i][j-1])  
            - selling today (prices[j] - effectiveBuyPrice)  
        update effectiveBuyPrice as min(effectiveBuyPrice, prices[j] - dp[i-1][j])  
return dp[k][n-1]  
```

ğŸ’» ğŸ”¡ Code Implementation  
```java
public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    int [][]dp = new int[k+1][n];
    if (n < 2) return 0;
    
    for (int i = 1; i <= k; i++) {
        int effectiveBuyPrice = prices[0];
        for (int j = 1; j < prices.length; j++) {
            dp[i][j] = Math.max(dp[i][j-1], prices[j] - effectiveBuyPrice);
            effectiveBuyPrice = Math.min(effectiveBuyPrice, prices[j] - dp[i-1][j]);
        }
    }
    
    return dp[k][n-1];
}
```

ğŸ”— ğŸ“š Similar Problems  
â¡ï¸ **Best Time to Buy and Sell Stock (Single Transaction)**  
â¡ï¸ **Best Time to Buy and Sell Stock II (Unlimited Transactions)**  
â¡ï¸ **Best Time to Buy and Sell Stock with Cooldown**  

ğŸ§ ğŸš€ Review Notes  
âœ… **Key Insights:** Track `effectiveBuyPrice` to minimize cost  
âŒ **Common Mistakes:** Forgetting to update `effectiveBuyPrice` correctly  
âš¡ **Optimization Tips:** Can optimize space to `O(n)` using rolling arrays
