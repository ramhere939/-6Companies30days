ğŸ“Œ ğŸ”¢ Maximum of All Subarrays of Size `k`  

ğŸ“… ğŸ–¥ï¸ Platform: [GFG]  
âš¡ ğŸ” Difficulty: [Medium]  

ğŸ” ğŸ“ Problem Understanding  
â¡ï¸ **Input:** Array `arr[]`, integer `k` (window size)  
â¡ï¸ **Output:** List of maximum values for each subarray of size `k`  

ğŸ“ ğŸ”¢ Constraints  
â¡ï¸ `1 â‰¤ k â‰¤ arr.length â‰¤ 10^6`  
â¡ï¸ `-10^7 â‰¤ arr[i] â‰¤ 10^7`  

ğŸ”„ ğŸ› ï¸ Edge Cases  
â¡ï¸ `arr` contains all negative or all positive numbers  
â¡ï¸ `k` equals `1` (output is the same as `arr`)  
â¡ï¸ `k` equals `arr.length` (output is single max value)  

ğŸ’¡ ğŸ” Approach  
ğŸ”¹ **Sliding Window using Deque**  
  ğŸ”¹ Use a `Deque` (double-ended queue) to store indices of useful elements  
  ğŸ”¹ **Maintain decreasing order** in `Deque`, removing smaller elements  
  ğŸ”¹ For each index `i`:  
    ğŸ”¹ Remove elements **out of window** (`i-k`)  
    ğŸ”¹ Remove elements **smaller than `arr[i]`**  
    ğŸ”¹ Add `i` to `Deque`  
    ğŸ”¹ Add `arr[dq.getFirst()]` to result when `i >= k-1`  

â³ â±ï¸ Time Complexity: **O(n)**  
ğŸ’¾ ğŸ—ï¸ Space Complexity: **O(k)**  

ğŸ“ ğŸ”¢ Pseudo Code  
```plaintext
initialize Deque and result list  
for each index i in arr:  
    remove elements outside window (i-k) from Deque  
    remove smaller elements from Deque  
    add index i to Deque  
    if i >= k-1, add arr[dq.getFirst()] to result  
return result  
```

ğŸ’» ğŸ”¡ Code Implementation  
```java
public ArrayList<Integer> max_of_subarrays(int arr[], int k) {
    Deque<Integer> dq = new ArrayDeque<>();
    ArrayList<Integer> ans = new ArrayList<>();
    
    for (int i = 0; i < arr.length; i++) {
        if (!dq.isEmpty() && dq.getFirst() == i - k) dq.removeFirst();
        while (!dq.isEmpty() && arr[dq.getLast()] <= arr[i]) dq.removeLast();
        dq.add(i);
        if (i >= k - 1) ans.add(arr[dq.getFirst()]);
    }
    
    return ans;
}
```

ğŸ”— ğŸ“š Similar Problems  
â¡ï¸ **Sliding Window Maximum**  
â¡ï¸ **Largest Rectangle in Histogram**  
â¡ï¸ **Stock Span Problem**  

ğŸ§ ğŸš€ Review Notes  
âœ… **Key Insights:** Maintain a decreasing order in `Deque`  
âŒ **Common Mistakes:** Forgetting to remove out-of-window elements  
âš¡ **Optimization Tips:** Use a `Deque` for `O(1)` max retrieval
