ğŸ“ Problem Name: Wiggle Sort  
ğŸ“… Date: [06-01-2025]  
ğŸŒ Platform: [LeetCode]  
âš¡ Difficulty: Medium  

ğŸ§ Problem Understanding  
ğŸ“Œ Input/Output  
â¡ Given an array `nums`, rearrange it such that:  
â¡ `nums[0] < nums[1] > nums[2] < nums[3] > ...`  

ğŸ“Œ Constraints  
âœ… `1 â‰¤ nums.length â‰¤ 5 Ã— 10â´`  
âœ… `0 â‰¤ nums[i] â‰¤ 5000`  

ğŸ“Œ Edge Cases  
âœ… Single element array  
âœ… Already sorted or reverse sorted array  
âœ… Large input sizes  

ğŸ’¡ Approach  

1ï¸âƒ£ Initial Thoughts  
â¡ Sorting and placing elements alternatively maintains the pattern  
â¡ A max heap can help with order  

2ï¸âƒ£ Optimal Solutions  

ğŸ”¹ Approach 1: Max Heap (Priority Queue)  
ğŸ“Œ Idea  
â¡ Store all elements in a max heap  
â¡ Place the largest remaining elements at odd indices  
â¡ Place remaining elements at even indices  

ğŸ“Œ Pseudocode  
â¡ Insert all elements into a max heap  
â¡ Iterate over odd indices (1, 3, 5...) and place the largest elements from the heap  
â¡ Iterate over even indices (0, 2, 4...) and place the remaining elements  

ğŸ”¹ Approach 2: Sorting + Two Pointers  
ğŸ“Œ Idea  
â¡ Sort the array in ascending order  
â¡ Use two pointers:  
ğŸ”¹ One at the end for filling odd indices  
ğŸ”¹ One at the middle for filling even indices  

ğŸ“Œ Pseudocode  
â¡ Sort the input array  
â¡ Use two pointers:  
ğŸ”¹ One at the last index for odd positions  
ğŸ”¹ One at the middle for even positions  
â¡ Assign values in decreasing order  

ğŸ”¹ Approach 3: Counting Sort (Bucket Array)  
ğŸ“Œ Idea  
â¡ Since `nums[i]` is in the range 0 - 5000, create a frequency array  
â¡ Fill elements from largest to smallest into odd and even indices  

ğŸ“Œ Pseudocode  
â¡ Create a frequency array for numbers in range 0 - 5000  
â¡ Start from the largest number and place elements at odd indices  
â¡ Once odd indices are filled, place remaining elements at even indices  

ğŸ”¹ Approach 4: In-Place Modification (Single Pass)  
ğŸ“Œ Idea  
â¡ Iterate through the array and swap elements to maintain the wiggle property  
ğŸ”¹ If `i` is even, ensure `nums[i] < nums[i+1]`  
ğŸ”¹ If `i` is odd, ensure `nums[i] > nums[i+1]`  

ğŸ“Œ Pseudocode  
â¡ Iterate through the nums array  
â¡ If `i` is even and `nums[i] > nums[i+1]`, swap them  
â¡ If `i` is odd and `nums[i] < nums[i+1]`, swap them  

â³ Time & Space Complexity  
âœ… Max Heap: `O(N log N)`  
âœ… Sorting + Two Pointers: `O(N log N)`  
âœ… Counting Sort: `O(N)`  
âœ… In-Place Modification: `O(N)` time, `O(1)` space  

ğŸ–¥ Code Template  
```java
class Solution {  
    public void wiggleSort(int[] nums) {  
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(b, a));  
        int n = nums.length;  
        
        for (int num : nums) pq.add(num);  
        
        for (int i = 1; i < n; i += 2) nums[i] = pq.poll();  
        for (int i = 0; i < n; i += 2) nums[i] = pq.poll();  
    }  
}  
```

ğŸ”— Similar Problems  
ğŸ“Œ Wiggle Subsequence  
ğŸ“Œ Dutch National Flag Problem  

ğŸ“Œ Review Notes  
âœ… Key Insights: Sorting helps establish an alternating order  
âš ï¸ Common Mistakes: Incorrect element placement while iterating  
ğŸš€ Optimization Tips: Use counting sort for an `O(N)` solution
